\documentclass[12pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[english]{babel}
\usepackage{cite}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{mathrsfs}
\usepackage{enumerate}
\usepackage{fullpage}
\usepackage[linkcolor=red]{hyperref}
\usepackage[final]{graphicx}
\usepackage{color}
\usepackage{minted}
\usepackage{listings}
\usepackage{url}
\renewcommand*\lstlistingname{Code Block}
\usemintedstyle{tango}
\definecolor{bg}{rgb}{0.95,0.95,0.95}

%caption distinct from normal text
\usepackage[hang,small,bf]{caption}
\usepackage{hyperref}

\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}

\numberwithin{listing}{section}

\author{
  \texttt{Simon Van Beest} \\[.4cm]
  \texttt{Kristian Høi}\\[.4cm]
    \texttt{André Lauridsen}\\[.4cm]
      \texttt{Mikkel Enevoldsen}\\[.4cm] 
  \vspace{10cm}
}

\title{
  \vspace{3cm}
  \Huge{Compilers Design} \\[.25cm]
  \vspace{.75cm}
}

\begin{document}

\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{includes/ku-farve}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{includes/ku-farve}}}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\AddToShipoutPicture*{\put(0,0){\includegraphics*{includes/ku-en}}}

\clearpage\maketitle
\thispagestyle{empty}

\newpage

\pagestyle{plain}
\setcounter{page}{1}
\pagenumbering{arabic}

\subsection*{Lexer and Parser}
In completing the compiler for fasto, we first look at the lexer. 
Here we have implimented true and false, so that the lexer recogknizes them as tokens.
'\&\&', \ '||', \ '!', and $'\sim'$ will also be recognized by the lexer as the logical operators 
'AND', 'OR', 'NOT' and 'NEGATE' respectively. 
Multiplication and division is handled in the same way as plus and minus, in the lexer as well as the parser.
\\\\
The fasto language has to support the functions, map, reduce and iota. 
In order to for that to happen 'map', 'reduce' and 'iota' has been added to the lexer.
As map and reduce allows for anonymous function we need the lexer to accept 'fn', '=>' and 'op'.
All of the abovestanding has been defined in the parser, coresponding to the expected syntax of the Fasto language.
In the parser we introduce FunArg, in order to handle regular and anonymous functions for map and reduce. Furthermore reduce has a case 
where it takes a binary operator as. To handle this we created the type 'BinOp', which supports multiplication, division, subtraction and addition. Each of the cases are translated into a lambda expression. 
\\\\
In the Parser all apropriate associativities has been added. 'OP', 'NEGATE' and 'NOT' are nonassociative as they are unary operators.
The rest is left associative. The order of precedence is clearly visible in the code, and is dictated by the definition of the Fasto language.


\subsection*{Interpreter}
Working with the interpreter we expanded on the 'evalExp' function to support multiplication, division, logical AND and OR operator, as well as NOT and NEGATE. Furthermore we added cases for the SOACs. Map is implimented using the provided functions 'evalFunArg' and 'rtpFunArg' as well as the helperfunction 'argHelper' we created. 'argHelper' takes an element and calls 'evalFunArg' using that element and the given funArg. We evaluate the specified arrayexpression recursively, and gets the returntype of the funArg by using 'rtpFunArg'. Using sml's 'map' function we create a new arrayVal with the expected returntype. \\ 'Reduce' is implimented in a similar way, using sml's 'foldl' function.  

\subsection*{Typechecker}
The cases mentioned for the 'evalExp' function above, are the same cases we handle in the 'checkExp' in the typechecker. 
Concerning map we make sure that the functions input type matches the array type, and that the function takes only one argument. 
For reduce ...   *TBA*   ...


\subsection*{Codegen for Map and Reduce}
Our approach for Map is that we are making two iterators for our arrays. One for the argument array and another for the result array. They are set to the address of the array, which we got by compiling the array argument and placing the address in "addr\_reg". The iterator for the result array is set to point at the place of the result address.\\
Then we use Mips.LW on "addr\_reg" to get the size of the result array and store it at the place address. Since our iterators is pointing at same element index for both result and argument array, we simply load the element from the argument array and apply the given function on it. Then we store it at the address pointed out by our result array iterator. For applying function on a given argument we have created a mutually recursive function "CompileFunArg" which generates the required Mips code for that.\\

In order to generic code for different types we are supporting (char, integer and bool) we either have to use Mips.LW or Mips.LB same goes for store operations.

The solution was to create two functions mipsStore and mipsLoad that both takes a type as argument and returns the correct Mips operation.\\
Then we simply create a "while" loop where we check if our index variable is greater then the size of the array. If so we jump to the end of the code. If not we load the element from the address pointed out by "r\_itx" and call CompileFunArg with the required argument. Last we store the result at the address pointed by "r\_ity", the we add the correct offset to our address pointers depending on type and jump back to the beginning of the loop. \\ \\
For reduce we used the same approach, except we only need one pointer (for the argument array). First we compile the neutral element and the array. Then we place them at the desired registers. We then move the neutral element into the result address, as we intent to save the function result of the given function in the place address. This simplifies it in our loop because the two arguments for our functions is the arr[i] and place. Then we save the result of the function in place for the next iteration for the loop.
\\
Our function "CompileFunArg" supports FunDec and Lambda expressions. In case of FunDec we simply create a new registe for the result and use the given function applyRegs with the function name, arguments, temp\_reg and position. Then we move the result from temp\_reg to place.\\
The Lambda case is more tricky. First we have to bind the parameters to the arguments and bind them to the vtable. In order to bind parameters and arguments to vtable we created a function "bindArgsToVtab" which takes two list parameters and arguments and a vtable. Then it recursively binds the pair param and arg into the vtable. When the lists are empty it returns the vtable. The function raises a Fail expection if arguments and parameters have different lengths.
%\bibliography{references}{}
%\bibliographystyle{plain}
\end{document}
